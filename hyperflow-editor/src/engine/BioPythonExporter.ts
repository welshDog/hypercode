import { type Node, type Edge } from 'reactflow';
import { type SequenceNodeData, type TranscribeNodeData, type TranslateNodeData, type EnzymeNodeData, type LigaseNodeData } from './BioTypes';

// --- Types ---
interface BioOp {
  id: string;
  type: 'sequence' | 'transcribe' | 'translate' | 'enzyme' | 'ligase' | 'crispr';
  sequence?: string;
  isValid?: boolean;
  data?: any; // To hold specific node data like enzyme name or fragments
}

// --- Helper: Topological Sort for Bio Pipeline ---
// Currently assumes a simple linear chain: DNA -> Transcribe -> Translate
const sortBioNodes = (nodes: Node[], _edges: Edge[]): BioOp[] => {
  // 1. Find the root DNA node (source)
  // In a real graph traversal, we'd use Kahn's algorithm or recursion.
  // For v1, we sort by x-position as a proxy for flow direction (left-to-right).

  const sorted = [...nodes].sort((a, b) => a.position.x - b.position.x);

  return sorted.map(node => {
    let type: BioOp['type'] | undefined;
    let sequence: string | undefined;
    let isValid: boolean | undefined;
    let data: any = undefined;

    if (node.type === 'sequence') {
      type = 'sequence';
      const d = node.data as SequenceNodeData;
      sequence = d.sequence;
      isValid = d.isValid;
    } else if (node.type === 'transcribe') {
      type = 'transcribe';
      const d = node.data as TranscribeNodeData;
      sequence = d.sequence;
      isValid = d.isValid;
    } else if (node.type === 'translate') {
      type = 'translate';
      const d = node.data as TranslateNodeData;
      sequence = d.sequence;
      isValid = d.isValid;
    } else if (node.type === 'enzyme') {
      type = 'enzyme';
      const d = node.data as EnzymeNodeData;
      isValid = d.isValid;
      data = { enzyme: d.enzyme || 'EcoRI', mode: d.mode };
    } else if (node.type === 'ligase') {
      type = 'ligase';
      const d = node.data as LigaseNodeData;
      isValid = d.isValid;
      sequence = d.ligatedSequence;
      data = { circular: d.circular };
    }

    if (type) {
      const op: BioOp = { id: node.id, type, sequence, isValid, data };
      return op;
    }
    return null;
  }).filter((op): op is BioOp => op !== null);
};

// --- Generator Function ---
export const generateBioPythonCode = (nodes: Node[], edges: Edge[]): string => {
  const ops = sortBioNodes(nodes, edges);

  // Header
  let code = `# Generated by HyperFlow Editor v1.2.0\n`;
  code += `# Bio-Lane: Molecular Cloning Pipeline\n\n`;
  code += `from Bio.Seq import Seq\n`;
  code += `from Bio.Restriction import *\n\n`;
  code += `def run_bio_pipeline():\n`;
  code += `    print("ğŸ§ª Starting Bio-Pipeline...")\n\n`;

  // Pipeline Logic
  let dnaVar = 'dna_seq';
  let rnaVar = 'rna_seq';
  let proteinVar = 'protein_seq';
  let fragsVar = 'fragments';
  let ligatedVar = 'ligated_seq';

  let hasDNA = false;
  let hasRNA = false;
  let dnaValid = false;
  let hasFragments = false;

  ops.forEach(op => {
    if (op.type === 'sequence') {
      code += `    # Node: DNA Source\n`;
      if (op.isValid === false) {
        code += `    # âš ï¸ Invalid DNA Sequence detected in editor\n`;
        code += `    print("âš ï¸ Error: Invalid DNA Sequence detected (contains non-ATGC characters)")\n`;
        code += `    ${dnaVar} = None\n\n`;
        dnaValid = false;
      } else {
        code += `    ${dnaVar} = Seq("${op.sequence || ''}")\n`;
        code += `    print(f"ğŸ§¬ DNA: {${dnaVar}}")\n\n`;
        dnaValid = true;
      }
      hasDNA = true;
    } else if (op.type === 'transcribe') {
      if (hasDNA && dnaValid) {
        code += `    # Node: Transcription (DNA -> RNA)\n`;
        code += `    ${rnaVar} = ${dnaVar}.transcribe()\n`;
        code += `    print(f"ğŸŒ«ï¸ RNA: {${rnaVar}}")\n\n`;
        hasRNA = true;
      } else {
        code += `    # Node: Transcription skipped due to invalid/missing upstream DNA\n`;
      }
    } else if (op.type === 'translate') {
      if (hasRNA && dnaValid) {
        code += `    # Node: Translation (RNA -> Protein)\n`;
        code += `    ${proteinVar} = ${rnaVar}.translate()\n`;
        code += `    print(f"ğŸ­ Protein: {${proteinVar}}")\n\n`;
      } else if (hasDNA && dnaValid) {
        code += `    # Node: Translation (Direct DNA -> Protein)\n`;
        code += `    ${proteinVar} = ${dnaVar}.translate()\n`;
        code += `    print(f"ğŸ­ Protein: {${proteinVar}}")\n\n`;
      }
    } else if (op.type === 'enzyme') {
      if (hasDNA && dnaValid) {
        const enzymeName = op.data.enzyme;
        code += `    # Node: Restriction Enzyme (${enzymeName})\n`;
        code += `    rb = ${enzymeName}\n`;
        code += `    # Note: BioPython restriction analysis\n`;
        code += `    ${fragsVar} = rb.catalyse(${dnaVar})\n`;
        code += `    print(f"âœ‚ï¸  Fragments ({enzymeName}): {len(${fragsVar})}")\n`;
        code += `    for i, f in enumerate(${fragsVar}):\n`;
        code += `        print(f"   Frag {i}: {f}")\n\n`;
        hasFragments = true;
      }
    } else if (op.type === 'ligase') {
      if (hasFragments) {
        code += `    # Node: Ligase\n`;
        if (op.isValid) {
          const isCircular = op.data.circular;
          const seqClean = (op.sequence || '').replace('â†º ', ''); // Remove visual marker
          code += `    ${ligatedVar} = Seq("${seqClean}")\n`;
          if (isCircular) {
            code += `    print(f"ğŸ” Ligated Circular Plasmid: {${ligatedVar}}")\n`;
          } else {
            code += `    print(f"ğŸ”— Ligated Linear Sequence: {${ligatedVar}}")\n`;
          }
        } else {
          code += `    print("âš ï¸ Ligation Failed: Incompatible fragments selected")\n`;
        }
        code += `\n`;
      }
    } else if (op.type === 'crispr') {
      if (hasDNA && dnaValid) {
        const gRNA = op.data.guideRNA || '';
        const pam = op.data.pam || 'NGG';
        code += `    # Node: CRISPR-Cas9 Target Search\n`;
        code += `    guide_rna = "${gRNA}"\n`;
        code += `    pam = "${pam}"\n`;
        code += `    # Construct Regex (N -> .)\n`;
        code += `    pam_regex = pam.replace('N', '.')\n`;
        code += `    target_regex = f"{guide_rna}{pam_regex}"\n`;
        code += `    matches = [m.start() for m in re.finditer(target_regex, str(${dnaVar}), re.IGNORECASE)]\n`;
        code += `    print(f"âœ‚ï¸  CRISPR Matches: {len(matches)} found at indices {matches}")\n`;
        code += `    if len(matches) > 0: print("   âœ… Target Acquired")\n`;
        code += `    else: print("   âŒ No Target Found")\n\n`;
      }
    }
  });

  code += `    print("âœ… Pipeline Complete.")\n`;
  return code;
};
